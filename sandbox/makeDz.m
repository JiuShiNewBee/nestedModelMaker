% ----------------------------------------------------------------------------- 
% "makeDzGrid.m".  This script makes dz grids for use in forward simulations
% in subdomains of the ASTE state estimate.  At the end, the script saves file
% 'zgrid_[name].mat' containing a strucutre called 'zgrid' with the fields:
%
%		zgrid.delz  	: vector of Delta z's. 
%		zgrid.zf    	: vector of face-points.
%		zgrid.iic		: vector of indices for the Delta z's (at cell-centers)
%		zgrid.iif		: vector of indices for the face-points.
%		zgrid.dzdelz	: vector of rate of change of delz, or "dz(delz)"
%		zgrid.name		: name of the grid.
%
% Key to various grids:
%	107a:	Equivalent to An's 'version 2'. Does not have a face-point at zf = 10m.
%	107b:	Equivalent to An's 'version 3'.	Hard-coded below.
%	107c:	Equivalent to An's 'version 5'.	Hard-coded below.
%	101a:	Grid generated by placing face-points half-way between the ASTE 
%				face-points. This method produces a jagged dz(delz).
%	102a:	Grid generated by using a spline to determine location of face-points.
%				This produces a smoother dz(delz) than 101a.
%	flex:	Custom grid with 10m spacing at the top, telescoping logarithmically 
%				to 80m spacing by iiz=40, and keeping uniform resolution down 
%				to ~6200m.
%
% glw Jan 22 2016
% ----------------------------------------------------------------------------- 
clear all

% Identify the grid-generation scheme.
%name = '101a';
%name = '101b';
name = 'flex';
%name = '107a';
%name = '107b';
%name = '107c';

% Number of decimal places to preserve
decimals = 2;
rounder  = 10^decimals;

% Two paths for loading and saving.
loadPath = [ pwd '/' ];
savePath = [ pwd '/' ];

% load the dz grid from aste
load([savePath 'asteDz.mat'])

% This scheme produces a grid with 101 face-points.  It has essentially twice the
% resolution of the aste grid.
if strcmp(name, '101a')

	% Grid-doubler.
	nz = 2*length(aste.zf)-1;

	% Initialize grid.
	zgrid.zf = zeros(1, nz);

	% Tie every other grid point to the aste z-grid.
	zgrid.zf(1:2:nz) = aste.zf;

	% Calculate the in-between face-points as half-way between aste face-points.
	zgrid.zf(2:2:(nz-1)) = (aste.zf(2:end)+aste.zf(1:end-1) )/2;

	% Calculate dz.  "zf" is in depth units, and therefore positive and increasing.
	zgrid.delz = zgrid.zf(2:end)-zgrid.zf(1:end-1);
	
% This scheme produces a grid with 101 face-points.  It has essentially twice the
% resolution of the aste grid. It takes an extra smoothing step to eliminate
% oscillation in dz(delz).
elseif strcmp(name, '101b')

	% Grid-doubler.
	nz = 2*length(aste.zf)-1;

	% The function of this is a little mysterious to me, but we're going 
	% to try it out.
	zgrid.zf = spline(1:2:nz, aste.zf, 1:nz);

	% Calculate dz.  "zf" is in depth units, and therefore positive and increasing.
	zgrid.delz = zgrid.zf(2:end)-zgrid.zf(1:end-1);

	% Round delz to two decimal points and recalculate face-points
	zgrid.delz = round(zgrid.delz*rounder)/rounder;
	zgrid.zf   = [0 cumsum(zgrid.zf)];

elseif strcmp(name, 'flex')

	% Build grid from three telescoping regions: one near-surface, 
	% one transition region, and one bottom out-telescope region.

	% Surface layer.
	nnSurf  = 20;
	dzSurf1 = 10;
	dzSurf2 = 20;
	dzSurf  = logspace(log10(dzSurf1), log10(dzSurf2), nnSurf);

	% Transition
	nnTran  = 20;
	dzTran1 = dzSurf2;
	dzTran2 = 80;
	dzTran  = logspace(log10(dzTran1), log10(dzTran2), nnTran);
	
	% Cut off first element.
	dzTran = dzTran(2:end);

	% Constant layer to 5600m
	zzTran = sum(dzSurf) + sum(dzTran);
	zzCons = zzTran:dzTran2:5600;
	nnCons = length(zzCons)-1;
	dzCons = dzTran2*ones(1,nnCons);

	% Bottom layer
	nnBott  = 9;
	dzBott1 = dzTran2;
	dzBott2 = dzTran2;
	dzBott  = logspace(log10(dzBott1), log10(dzBott2), nnBott);
	
	% Cut off first element.
	dzBott = dzBott(2:end);

	% Paste together all dz's to construct a new grid.
	zgrid.delz = [ dzSurf dzTran dzCons dzBott ];


elseif strcmp(name, '107a')

	% z-location of faces
  	zf = [0 cumsum(aste.delz)];
	
	% size of zgrid grid
  	nz = 107;

	% Indices of tie-in face-points on zgrid grid. For example, face 1, 8, and 11 
	% on the zgrid grid are shared with the aste grid.
	il = [1 8 11:2:nz];
	
	% Index of faces.
	ik = 1:51;
	
	% Select face-points of zgrid grid using a spline.
	zgrid.delz = diff( spline(il, zf, 1:nz) );
	zgrid.zf   = [0 cumsum(zgrid.delz)];

	% ???
  	zgrid.delzp = zgrid.zf;

	% Make things monotonic?
  	zgrid.delzp(1:4) = zgrid.delz([3 2 4 1]);
  	zgrid.delzp(3)   = zgrid.delzp(3)+.03;
  	zgrid.delzp(4)   = zgrid.delzp(4)-.03;

elseif strcmp(name, '107b')

	% "Version 3"
    zgrid.delz = [	0.93    1.01    1.14    1.32    1.56    1.85    2.19    2.61    3.25    4.14 ...
				    5.00    5.00    5.00    5.00    5.00    5.00    5.00    5.00    5.00    5.00 ...
				    5.00    5.01    5.01    5.02    5.04    5.07    5.12    5.20    5.31    5.49 ...
				    5.72    6.04    6.45    6.97    7.62    8.42    9.36   10.46   11.72   13.13 ...
				   14.70   16.40   18.24   20.18   22.21   24.29   26.43   28.57   30.71   32.79 ...
				   34.82   36.76   38.60   40.30   41.87   43.28   44.54   45.64   46.58   47.38 ...
				   48.03   48.55   48.96   49.29   49.53   49.72   49.90   50.11   50.41   50.92 ...
				   51.69   52.87   54.54   56.79   59.67   63.16   67.26   71.83   76.83   82.11 ...
				   87.61   93.22   98.91  104.64  110.38  116.12  121.87  127.63  133.38  139.12 ...
				  144.87  150.63  156.38  162.12  167.87  173.63  179.38  185.12  190.87  196.63 ...
				  202.38  208.12  213.87  219.63  225.38  231.12 ];

elseif strcmp(name, '107c')

	% "Version 5"
    zgrid.delz = [	0.60    0.71    0.90    1.16    1.50    1.91    2.39    2.95    3.58    4.29 ...
					5.00    5.00    5.00    5.00    5.00    5.00    5.00    5.00    5.00    5.00 ...
					5.00    5.01    5.01    5.02    5.04    5.07    5.12    5.20    5.31    5.49 ...
					5.72    6.04    6.45    6.97    7.62    8.42    9.36   10.46   11.72   13.13 ...
				   14.70   16.40   18.24   20.18   22.21   24.29   26.43   28.57   30.71   32.79 ...
				   34.82   36.76   38.60   40.30   41.87   43.28   44.54   45.64   46.58   47.38 ...
				   48.03   48.55   48.97   49.28   49.53   49.72   49.90   50.11   50.41   50.92 ...
				   51.69   52.87   54.54   56.79   59.67   63.16   67.26   71.83   76.83   82.11 ...
				   87.61   93.22   98.91  104.64  110.38  116.12  121.87  127.63  133.38  139.12 ...
				  144.88  150.62  156.38  162.12  167.88  173.62  179.38  185.12  190.88  196.62 ...
				  202.38  208.12  213.88  219.62  225.38  231.12 ];

else
	error(['There is no grid-generation scheme with the name ' name ', unfortunately.'])
end

%%% Some post-processing ------------------------------------------------------ 

% Round delz to a small number of decimals (specified in 'decimals' variable).
zgrid.delz = round(zgrid.delz*rounder)/rounder;

% Recalculate face-points.
zgrid.zf   = [0 cumsum(zgrid.delz)];

% Calculate d (dZ) / dz with a first-order forward difference.
zgrid.dzdelz = 2*(zgrid.delz(2:end)-zgrid.delz(1:end-1)) ...
					./(zgrid.delz(2:end)+zgrid.delz(1:end-1));

% Index vectors for convenience.
zgrid.iif = 0:(length(zgrid.zf)-1);
zgrid.iic = (zgrid.iif(2:end)+zgrid.iif(1:end-1) )/2;

% Name of the grid.
zgrid.name = name;

% Save the result
save([ savePath 'zgrid_' name '.mat'], 'zgrid')

% Display some info.
disp(' ')
disp(['We made a z-grid named ''' name '''.  ' ...
 		'The grid is saved in '])
disp(' ')
disp([savePath 'zgrid_' name '.mat'])
disp(' ')
disp(['The new grid has ' num2str(length(zgrid.delz),'%d') ' dz''s and ' ...
		num2str(length(zgrid.zf),'%d') ' face-points.'])
disp(['The bottom of the last z-cell is at depth ' ...
		num2str(zgrid.zf(end), '%7.2f'), ' meters'])
disp(' ')
